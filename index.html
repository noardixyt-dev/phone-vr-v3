<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>VR Phone Camera HUD</title>
<style>
  html,body { height:100%; margin:0; background:#000; color:#fff; font-family:system-ui, -apple-system, sans-serif; overflow:hidden; }
  #container { width:100%; height:100vh; display:flex; align-items:center; justify-content:center; overflow:hidden; position:relative; }
  .eyeCanvas { background:#000; position:absolute; }
  .btn { background:#111; color:#fff; border:1px solid #333; padding:6px 8px; border-radius:6px; cursor:pointer; }
  .btn:active { transform:translateY(1px); }
  label { font-size:13px; display:flex; gap:4px; align-items:center; color:#ddd; }
  input[type=range] { width:120px; }
</style>
</head>
<body>
<div id="container">
  <canvas id="left" class="eyeCanvas"></canvas>
  <canvas id="right" class="eyeCanvas"></canvas>
</div>

<video id="video" autoplay playsinline muted style="display:none;"></video>

<script>
const video = document.getElementById('video');
const leftCanvas = document.getElementById('left');
const rightCanvas = document.getElementById('right');
const zoomControl = document.createElement('input');
zoomControl.type = 'range'; zoomControl.min='1'; zoomControl.max='2'; zoomControl.step='0.01'; zoomControl.value='1';
const zoomVal = document.createElement('span'); zoomVal.textContent='1.00';
const mirrorChk = document.createElement('input'); mirrorChk.type='checkbox';

let stream = null;
let usingFacingMode = 'environment';
let rafId = null;
let zoom = parseFloat(zoomControl.value);
let mirror = false;
let eyeGap = 20;

const rotCanvas = document.createElement('canvas'), rotCtx = rotCanvas.getContext('2d');

let menuAngle = 0; // current angle of the menu relative to forward
let menuVisible = false;

function stopStream() {
  if (stream) { stream.getTracks().forEach(t=>t.stop()); stream=null; }
  if (rafId) { cancelAnimationFrame(rafId); rafId=null; }
}

async function startCamera() {
  stopStream();
  try {
    const constraints = { audio:false, video:{ facingMode:{ideal:usingFacingMode}, width:{ideal:1920}, height:{ideal:1080} } };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    resizeCanvases();
    drawLoop();
  } catch(err) { alert('Camera error: '+(err.message||err)); console.error(err); }
}

async function tryFlipCamera() { usingFacingMode = usingFacingMode==='environment'?'user':'environment'; await startCamera(); }

function resizeCanvases() {
  const dpr=window.devicePixelRatio||1;
  const w=window.innerWidth, h=window.innerHeight;
  const scale = 0.85;
  const eyeW=Math.floor(w*scale/2), eyeH=Math.floor(h*scale);
  leftCanvas.style.width = rightCanvas.style.width = eyeW+'px';
  leftCanvas.style.height = rightCanvas.style.height = eyeH+'px';
  leftCanvas.width = rightCanvas.width = Math.floor(eyeW*dpr);
  leftCanvas.height = rightCanvas.height = Math.floor(eyeH*dpr);

  const totalWidth = eyeW*2 + eyeGap;
  leftCanvas.style.left = `calc(50% - ${totalWidth/2}px)`;
  rightCanvas.style.left = `calc(50% - ${totalWidth/2}px + ${eyeW + eyeGap}px)`;
  leftCanvas.style.top = rightCanvas.style.top = `calc(50% - ${eyeH/2}px)`;
}
window.addEventListener('resize', resizeCanvases);

zoomControl.addEventListener('input', e=>{ zoom=parseFloat(e.target.value)||1; zoomVal.textContent=zoom.toFixed(2); });
mirrorChk.addEventListener('change', e=>{ mirror=e.target.checked; });

async function enumerateCameras() {
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d=>d.kind==='videoinput');
  } catch(err) { console.warn(err); }
}
enumerateCameras();

function ensureRotated(svw, svh){
  if(svh <= svw) return {src:video,w:svw,h:svh};
  if(rotCanvas.width!==svh || rotCanvas.height!==svw){ rotCanvas.width=svh; rotCanvas.height=svw; }
  rotCtx.save(); rotCtx.clearRect(0,0,rotCanvas.width,rotCanvas.height);
  rotCtx.translate(rotCanvas.width,0); rotCtx.rotate(Math.PI/2);
  rotCtx.drawImage(video,0,0,svw,svh); rotCtx.restore();
  return {src:rotCanvas,w:rotCanvas.width,h:rotCanvas.height};
}

let deviceOrientation = 0;
window.addEventListener('deviceorientation', e=>{
  deviceOrientation = e.alpha || 0; // yaw
});

function drawMenu(ctx, canvas){
  if(!menuVisible) return;
  const w = 160, h = 90;
  const centerX = canvas.width/2, centerY = canvas.height/2;
  const radius = 200; // fixed distance from center
  // compute position based on device orientation and menuAngle
  const angleRad = ((menuAngle - deviceOrientation) * Math.PI/180);
  const x = centerX + radius * Math.sin(angleRad) - w/2;
  const y = centerY - h/2;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(x, y, w, h);
  ctx.fillStyle='white'; ctx.font='14px sans-serif';
  ctx.fillText('Start Camera', x+10, y+25);
  ctx.fillText('Flip Camera', x+10, y+50);
  ctx.fillText('Fullscreen', x+10, y+75);
}

function drawCrosshair(ctx){
  const cx = ctx.canvas.width/2, cy = ctx.canvas.height/2;
  ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(cx-10,cy); ctx.lineTo(cx+10,cy); ctx.moveTo(cx,cy-10); ctx.lineTo(cx,cy+10); ctx.stroke();
  ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(cx,cy,3,0,2*Math.PI); ctx.fill();
}

function drawLoop(){
  const ctxL = leftCanvas.getContext('2d');
  const ctxR = rightCanvas.getContext('2d');
  const svw = video.videoWidth, svh = video.videoHeight;
  if(!svw || !svh){ rafId=requestAnimationFrame(drawLoop); return; }
  const {src,w,h} = ensureRotated(svw, svh);

  [ctxL, ctxR].forEach(ctx=>{
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    const sw = w/zoom, sh = h/zoom;
    const sx = (w - sw)/2, sy = (h - sh)/2;
    ctx.drawImage(src, sx, sy, sw, sh, 0, 0, ctx.canvas.width, ctx.canvas.height);
    drawCrosshair(ctx);
    drawMenu(ctx, ctx.canvas);
  });

  rafId=requestAnimationFrame(drawLoop);
}

// Show menu in front of you
window.addEventListener('click', ()=>{ menuVisible = true; menuAngle = deviceOrientation; });

startCamera();
</script>
</body>
</html>
