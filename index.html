<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>VR Phone Camera HUD</title>
<style>
  html,body { height:100%; margin:0; background:#000; color:#fff; font-family:system-ui, -apple-system, sans-serif; overflow:hidden; }
  #container { width:100%; height:100vh; display:flex; align-items:center; justify-content:center; overflow:hidden; position:relative; }
  .eyeCanvas { background:#000; position:absolute; }
  .btn { background:#111; color:#fff; border:1px solid #333; padding:6px 8px; border-radius:6px; cursor:pointer; }
  .btn:active { transform:translateY(1px); }
  label { font-size:13px; display:flex; gap:4px; align-items:center; color:#ddd; }
  input[type=range] { width:120px; }
</style>
</head>
<body>
<div id="container">
  <canvas id="left" class="eyeCanvas"></canvas>
  <canvas id="right" class="eyeCanvas"></canvas>
</div>

<video id="video" autoplay playsinline muted style="display:none;"></video>

<script>
const video = document.getElementById('video');
const leftCanvas = document.getElementById('left');
const rightCanvas = document.getElementById('right');

let stream = null;
let rafId = null;
let zoom = 1;
let eyeGap = 20;

const rotCanvas = document.createElement('canvas'), rotCtx = rotCanvas.getContext('2d');

let menuVisible = false;
let menuAngle = 0; // the angle where the menu is spawned
let deviceYaw = 0, devicePitch = 0;

function stopStream() {
  if (stream) { stream.getTracks().forEach(t=>t.stop()); stream=null; }
  if (rafId) { cancelAnimationFrame(rafId); rafId=null; }
}

async function startCamera() {
  stopStream();
  try {
    const constraints = { audio:false, video:{ facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080} } };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    resizeCanvases();
    drawLoop();
  } catch(err) { alert('Camera error: '+(err.message||err)); console.error(err); }
}

function resizeCanvases() {
  const dpr=window.devicePixelRatio||1;
  const w=window.innerWidth, h=window.innerHeight;
  const scale = 0.85;
  const eyeW=Math.floor(w*scale/2), eyeH=Math.floor(h*scale);
  leftCanvas.style.width = rightCanvas.style.width = eyeW+'px';
  leftCanvas.style.height = rightCanvas.style.height = eyeH+'px';
  leftCanvas.width = rightCanvas.width = Math.floor(eyeW*dpr);
  leftCanvas.height = rightCanvas.height = Math.floor(eyeH*dpr);
  const totalWidth = eyeW*2 + eyeGap;
  leftCanvas.style.left = `calc(50% - ${totalWidth/2}px)`;
  rightCanvas.style.left = `calc(50% - ${totalWidth/2}px + ${eyeW + eyeGap}px)`;
  leftCanvas.style.top = rightCanvas.style.top = `calc(50% - ${eyeH/2}px)`;
}
window.addEventListener('resize', resizeCanvases);

function ensureRotated(svw, svh){
  if(svh <= svw) return {src:video,w:svw,h:svh};
  if(rotCanvas.width!==svh || rotCanvas.height!==svw){ rotCanvas.width=svh; rotCanvas.height=svw; }
  rotCtx.save(); rotCtx.clearRect(0,0,rotCanvas.width,rotCanvas.height);
  rotCtx.translate(rotCanvas.width,0); rotCtx.rotate(Math.PI/2);
  rotCtx.drawImage(video,0,0,svw,svh); rotCtx.restore();
  return {src:rotCanvas,w:rotCanvas.width,h:rotCanvas.height};
}

window.addEventListener('deviceorientation', e=>{
  deviceYaw = e.alpha || 0; // left-right rotation
  devicePitch = e.beta || 0; // up-down rotation
});

function drawMenu(ctx, canvas){
  if(!menuVisible) return;
  const w = 160, h = 90;
  const centerX = canvas.width/2, centerY = canvas.height/2;
  const radius = 200;
  // Mirror the rotation to make it stay in place relative to world
  const yawOffset = ((menuAngle - deviceYaw + 360) % 360) * Math.PI/180;
  const pitchOffset = ((0 - devicePitch) * Math.PI/180); // simple up/down mapping
  const x = centerX + radius * Math.sin(yawOffset) - w/2;
  const y = centerY - radius * Math.sin(pitchOffset) - h/2;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(x, y, w, h);
  ctx.fillStyle='white'; ctx.font='14px sans-serif';
  ctx.fillText('Start Camera', x+10, y+25);
  ctx.fillText('Flip Camera', x+10, y+50);
  ctx.fillText('Fullscreen', x+10, y+75);
}

function drawCrosshair(ctx){
  const cx = ctx.canvas.width/2, cy = ctx.canvas.height/2;
  ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(cx-10,cy); ctx.lineTo(cx+10,cy); ctx.moveTo(cx,cy-10); ctx.lineTo(cx,cy+10); ctx.stroke();
  ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(cx,cy,3,0,2*Math.PI); ctx.fill();
}

function drawLoop(){
  const ctxL = leftCanvas.getContext('2d');
  const ctxR = rightCanvas.getContext('2d');
  const svw = video.videoWidth, svh = video.videoHeight;
  if(!svw || !svh){ rafId=requestAnimationFrame(drawLoop); return; }
  const {src,w,h} = ensureRotated(svw, svh);
  [ctxL, ctxR].forEach(ctx=>{
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    const sw = w/zoom, sh = h/zoom;
    const sx = (w - sw)/2, sy = (h - sh)/2;
    ctx.drawImage(src, sx, sy, sw, sh, 0, 0, ctx.canvas.width, ctx.canvas.height);
    drawCrosshair(ctx);
    drawMenu(ctx, ctx.canvas);
  });
  rafId=requestAnimationFrame(drawLoop);
}

// Spawn menu in front of user
window.addEventListener('click', ()=>{ menuVisible = true; menuAngle = deviceYaw; });

startCamera();
</script>
</body>
</html>
